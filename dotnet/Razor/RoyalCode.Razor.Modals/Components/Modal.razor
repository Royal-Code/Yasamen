@using Microsoft.AspNetCore.Components.Sections

@implements IAsyncDisposable
@inject ModalService ModalService

<SectionContent SectionId="item">
    <div class="@Classes" id="@Id" @ref="element" @ontransitionend="@transitionEndHandler">
        <CascadingValue Value="context" IsFixed="true">
            @ChildContent
        </CascadingValue>
    </div>
</SectionContent>

@code {

    public static int ModalMaxTransitionTime { get; set; } = 800;

    private string Classes => "ya-modal"
        .AddClass(phase == TransitionPhases.OpeningStart, "ya-modal-opening-start")
        .AddClass(phase == TransitionPhases.Opening, "ya-modal-opening")
        .AddClass(phase == TransitionPhases.Opened, "ya-modal-opened")
        .AddClass(phase == TransitionPhases.ClosingStart, "ya-modal-closing-start")
        .AddClass(phase == TransitionPhases.Closing, "ya-modal-closing")
        .AddClass(Center, "ya-modal-center");

    private readonly ModalContext context;
    private readonly ModalItem item;
    private readonly Func<Task> transitionEndHandler;

    private ElementReference element;

    private bool disposed;
    private TransitionPhases phase = TransitionPhases.Closed;

    public Modal()
    {
        context = new()
        {
            Modal = this,
        };
    }

    [Parameter, EditorRequired]
    public string Id { get; set; } = default!;

    [Parameter]
    public RenderFragment ChildContent { get; set; } = default!;

    [Parameter]
    public ModalHandler? Handler { get; set; }

    [Parameter]
    public bool Closeable { get; set; } = true;

    [Parameter]
    public bool Center { get; set; } = true;

    [Parameter]
    public EventCallback<ModalEventArgs> OnOpenClose { get; set; }


    protected override Task OnInitializedAsync()
    {
        ModalService.Add(item);
        return Task.CompletedTask;
    }

    protected override void OnParametersSet()
    {
        // id is required
        if (string.IsNullOrWhiteSpace(Id))
            throw new InvalidOperationException($"The type {GetType()} requires a value for the parameter {nameof(Id)}.");

        if (context.Handler is null)
        {
            context.Handler = Handler ?? new ModalHandler();
            context.Handler.Modal = this;
        }
        else if (Handler is not null && Handler != context.Handler)
        {
            throw new InvalidOperationException(
                $"The parameter {nameof(Handler)} must be the same instance for the same modal.");
        }

        item.Closeable = Closeable;

        base.OnParametersSet();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            context.Element = element;
        }
    }

    public async Task OpenAsync()
    {
        if (disposed)
            throw new ObjectDisposedException(GetType().Name, $"Modal [{Id}] was disposed");

        await ModalService.OpenAsync(item);
    }

    public async Task CloseAsync()
    {
        if (disposed)
            throw new ObjectDisposedException(GetType().Name, $"Modal [{Id}] was disposed");

        await ModalService.CloseAsync(item);
    }

    public async ValueTask DisposeAsync()
    {
        disposed = true;

        ModalService.Remove(item);
    }
}
