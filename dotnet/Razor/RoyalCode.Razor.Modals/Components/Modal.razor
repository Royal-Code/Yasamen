@using Microsoft.AspNetCore.Components.Sections

@implements IAsyncDisposable
@inject ModalService ModalService

<SectionContent SectionId="item">
    <div class="@Classes" id="@Id" @ref="element" @ontransitionend="@transitionEndHandler">
        <CascadingValue Value="context" IsFixed="true">
            @ChildContent
        </CascadingValue>
    </div>
</SectionContent>

@code {

    public static int ModalMaxTransitionTime { get; set; } = 800;

    private string Classes => "ya-modal"
        .AddClass(phase == ModalPhase.Opened, "ya-modal-show")
        .AddClass(phase == ModalPhase.Opening, "ya-modal-opening")
        .AddClass(phase == ModalPhase.Closing, "ya-modal-closing")
        .AddClass(Center, "ya-modal-center");

    private readonly ModalContext context;
    private readonly ModalItem item;
    private readonly Func<Task> transitionEndHandler;

    private ElementReference element;

    private bool disposed;
    private ModalPhase phase = ModalPhase.Closed;
    private ModalAction? currentAction;

    public Modal()
    {
        context = new()
        {
            Modal = this,
        };
        item = new ModalItem(PerformAsync);
        transitionEndHandler = TransitionEndHandler;
    }

    [Parameter, EditorRequired]
    public string Id { get; set; } = default!;

    [Parameter]
    public RenderFragment ChildContent { get; set; } = default!;

    [Parameter]
    public ModalHandler? Handler { get; set; }

    [Parameter]
    public bool Closeable { get; set; } = true;

    [Parameter]
    public bool Center { get; set; } = true;

    [Parameter]
    public EventCallback<ModalEventArgs> OnOpenClose { get; set; }

    private async Task PerformAsync(ModalAction action)
    {
        if (disposed)
            return;

        // end the old task
        if (currentAction is not null)
            await currentAction.Completed();

        await InvokeAsync(async () =>
        {
            currentAction = action;
            if (action.Type == ModalActionType.Open)
            {
                phase = ModalPhase.Opening;
            }
            else
            {
				phase = ModalPhase.Closing;

                var action = currentAction;
                await Task.Run(async () =>
                {
                    await Task.Delay(300);
                    if (action == currentAction)
                        await TransitionEndHandler();
                });
            }
			StateHasChanged();
        });
    }

    public async Task TransitionEndHandler()
    {
        if (currentAction is null)
            return;

        await currentAction.Completed();
        currentAction = null;

        if (phase == ModalPhase.Closing)
            await InvokeAsync(async () =>
            {
                phase = ModalPhase.Closed;
                StateHasChanged();
            });
    }

    protected override Task OnInitializedAsync()
    {
        ModalService.Add(item);
        return Task.CompletedTask;
    }

    protected override void OnParametersSet()
    {
        // id is required
        if (string.IsNullOrWhiteSpace(Id))
            throw new InvalidOperationException($"The type {GetType()} requires a value for the parameter {nameof(Id)}.");

        if (context.Handler is null)
        {
            context.Handler = Handler ?? new ModalHandler();
            context.Handler.Modal = this;
        }
        else if (Handler is not null && Handler != context.Handler)
        {
            throw new InvalidOperationException(
                $"The parameter {nameof(Handler)} must be the same instance for the same modal.");
        }

        item.Closeable = Closeable;

        base.OnParametersSet();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            context.Element = element;
        }

        if (phase == ModalPhase.Opening)
        {
            await InvokeAsync(async () =>
            {
                await Task.Delay(10);
                phase = ModalPhase.Opened;
                StateHasChanged();

                var action = currentAction;
                await Task.Run(async () =>
                {
                    await Task.Delay(300);
                    if (action == currentAction)
                        await TransitionEndHandler();
                });
            });
        }
    }

    public async Task OpenAsync()
    {
        if (disposed)
            throw new ObjectDisposedException(GetType().Name, $"Modal [{Id}] was disposed");

        if (phase != ModalPhase.Closed)
            return;

        await ModalService.OpenAsync(item);
    }

    public async Task CloseAsync()
    {
        if (disposed)
            throw new ObjectDisposedException(GetType().Name, $"Modal [{Id}] was disposed");

        if (phase != ModalPhase.Opened)
            return;

        await ModalService.CloseAsync(item);
    }

    public async ValueTask DisposeAsync()
    {
        disposed = true;

        if (phase != ModalPhase.Closed)
            await ModalService.CloseAsync(item);

        if (currentAction is not null)
            await currentAction.Completed();

        ModalService.Remove(item);
    }
}
