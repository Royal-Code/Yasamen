@using Microsoft.AspNetCore.Components.Sections

@implements IAsyncDisposable
@inject ModalService ModalService

<SectionContent SectionId="state">
    <div class="@Classes" id="@Id" @ref="element" @ontransitionEnded="transitionEndedHandler">
        <CascadingValue Value="context" IsFixed="true">
            @ChildContent
        </CascadingValue>
    </div>
</SectionContent>

@code {

    public static int ModalMaxTransitionTime { get; set; } = 800;

    private string Classes => "ya-modal"
        .AddClass(state.Phase == TransitionPhases.OpeningStart, "ya-modal-opening-start")
        .AddClass(state.Phase == TransitionPhases.Opening, "ya-modal-opening")
        .AddClass(state.Phase == TransitionPhases.Open, "ya-modal-open")
        .AddClass(state.Phase == TransitionPhases.ClosingStart, "ya-modal-closing-start")
        .AddClass(state.Phase == TransitionPhases.Closing, "ya-modal-closing")
        .AddClass(state.Phase == TransitionPhases.Closed, "ya-modal-closed")
        .AddClass(Center, "ya-modal-center");

    private readonly ModalContext context;
    private readonly ModalState state;
    private readonly Func<TransitionEndedEventArgs, Task> transitionEndedHandler;

    private TransitionPhases lastPhase = TransitionPhases.Closed;
    private ElementReference element;
    private bool disposed;

    public Modal()
    {
        context = new()
        {
            Modal = this,
        };
        state = new(() => InvokeAsync(StateHasChanged));
        transitionEndedHandler = TransitionEndedHandler;
    }

    [Parameter, EditorRequired]
    public string Id { get; set; } = default!;

    [Parameter]
    public RenderFragment ChildContent { get; set; } = default!;

    [Parameter]
    public ModalHandler? Handler { get; set; }

    [Parameter]
    public bool Closeable { get; set; } = true;

    [Parameter]
    public bool Center { get; set; } = true;

    [Parameter]
    public EventCallback<ModalEventArgs> OnOpenClose { get; set; }

    private async Task TransitionEndedHandler(TransitionEndedEventArgs args)
    {
        if (args.ElementId != Id || args.PropertyName != "transform")
            return;
        await state.CompleteAsync();
    }

    protected override Task OnInitializedAsync()
    {
        ModalService.Add(state);
        return Task.CompletedTask;
    }

    protected override void OnParametersSet()
    {
        // id is required
        if (string.IsNullOrWhiteSpace(Id))
            throw new InvalidOperationException($"The type {GetType()} requires a value for the parameter {nameof(Id)}.");

        if (context.Handler is null)
        {
            context.Handler = Handler ?? new ModalHandler();
            context.Handler.Modal = this;
        }
        else if (Handler is not null && Handler != context.Handler)
        {
            throw new InvalidOperationException(
                $"The parameter {nameof(Handler)} must be the same instance for the same modal.");
        }

        state.Closeable = Closeable;

        base.OnParametersSet();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            context.Element = element;
        }
        if (lastPhase != state.Phase)
        {
            lastPhase = state.Phase;
            if (state.Phase == TransitionPhases.Open)
            {
                await ModalService.ModalOpenedAsync();
                if (OnOpenClose.HasDelegate)
                    await OnOpenClose.InvokeAsync(new ModalEventArgs() { Modal = this, IsOpen = true });
            }
            else if (state.Phase == TransitionPhases.Closed)
            {
                await ModalService.ModalClosedAsync();
                if (OnOpenClose.HasDelegate)
					await OnOpenClose.InvokeAsync(new ModalEventArgs() { Modal = this, IsOpen = false });
            }
        }
        if (state.Phase is TransitionPhases.OpeningStart or TransitionPhases.ClosingStart)
        {
            await state.PromoteAsync();
        }
    }

    public async Task OpenAsync()
    {
        if (disposed)
            throw new ObjectDisposedException(GetType().Name, $"Modal [{Id}] was disposed");

        await ModalService.OpenAsync(state);
    }

    public async Task CloseAsync()
    {
        if (disposed)
            throw new ObjectDisposedException(GetType().Name, $"Modal [{Id}] was disposed");

        await ModalService.CloseAsync(state);
    }

    public async ValueTask DisposeAsync()
    {
        disposed = true;

        ModalService.Remove(state);
    }
}
