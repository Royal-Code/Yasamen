@using Microsoft.AspNetCore.Components.Sections

@implements IAsyncDisposable
@inject ModalService ModalService

<SectionContent SectionId="item">
    <div class="@Classes" id="@Id" @ref="element" @ontransitionend="@transitionEndHandler">
        <CascadingValue Value="context" IsFixed="true">
            @ChildContent
        </CascadingValue>
    </div>
</SectionContent>

@code {

    public static int ModalMaxTransitionTime { get; set; } = 800;

    private string Classes => "ya-modal"
        .AddClass(isOpen || closing, "ya-modal-show")
        .AddClass(opening, "ya-modal-opening")
        .AddClass(closing, "ya-modal-closing")
        .AddClass(Center, "ya-modal-center");

    private readonly ModalContext context;
    private readonly ModalItem item;
    private readonly Func<Task> transitionEndHandler;

    private ElementReference element;
    private AnimationCompletion? animation;

    private bool disposed;
    private bool opening;
    private bool closing;
    private bool closeRequested;
    private bool isOpen;

    public Modal()
    {
        context = new()
        {
            Modal = this,
        };
        item = new ModalItem(StateHasChangedAsync);
        transitionEndHandler = TransitionEndHandler;
    }

    [Parameter, EditorRequired]
    public string Id { get; set; } = default!;

    [Parameter]
    public RenderFragment ChildContent { get; set; } = default!;

    [Parameter]
    public ModalHandler? Handler { get; set; }

    [Parameter]
    public bool Closeable { get; set; } = true;

    [Parameter]
    public bool Center { get; set; } = true;

    [Parameter]
    public EventCallback<ModalEventArgs> OnOpenClose { get; set; }

    private Task StateHasChangedAsync()
    {
        if (disposed || isOpen == item.IsOpen)
			return Task.CompletedTask;

        // end the old task
        animation?.Complete();

        if (item.IsOpen)
            return InternalOpenAsync();
        else
			return InternalCloseAsync();
    }

    private Task InternalOpenAsync()
    {
		opening = true;
        closing = false;
        closeRequested = false;

        StateHasChanged();
		animation = new AnimationCompletion(ModalMaxTransitionTime);
		return animation.Task;
    }

    private Task InternalCloseAsync()
    {
		opening = false;
        closing = false;
		closeRequested = true;

		StateHasChanged();
        animation = new AnimationCompletion(ModalMaxTransitionTime);
		return animation.Task;
    }

    private async Task CompleteTransitionEndTask()
    {
        animation?.Complete();
        animation = null;

        isOpen = item.IsOpen;
        opening = false;
        closing = false;
        closeRequested = false;

        var evt = new ModalEventArgs()
        {
            IsOpen = isOpen,
            Modal = this
        };

        await OnOpenClose.InvokeAsync(evt);

        if (context.Handler is not null)
            await context.Handler.OnModalEventAsync(evt);

        StateHasChanged();

        if (isOpen && element.Id.IsPresent())
            await element.FocusAsync();
    }

    public async Task TransitionEndHandler()
    {
        Tracer.Write<Modal>(
            "TransitionEndHandler",
            "TransitionEndHandler called, isOpen: {0}, opening: {1}, closing: {2}", isOpen, opening, closing);

        await CompleteTransitionEndTask();
    }

    protected override Task OnInitializedAsync()
    {
        ModalService.Add(item);
        return Task.CompletedTask;
    }

    protected override void OnParametersSet()
    {
        // id is required
        if (string.IsNullOrWhiteSpace(Id))
            throw new InvalidOperationException($"The type {GetType()} requires a value for the parameter {nameof(Id)}.");

        if (context.Handler is null)
        {
            context.Handler = Handler ?? new ModalHandler();
            context.Handler.Modal = this;
        }
        else if (Handler is not null && Handler != context.Handler)
        {
            throw new InvalidOperationException(
                $"The parameter {nameof(Handler)} must be the same instance for the same modal.");
        }

        item.Closeable = Closeable;

        base.OnParametersSet();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            context.Element = element;
        }
        if (opening)
        {
            await InvokeAsync(async () =>
            {
                await Task.Delay(10);

				isOpen = true;
                opening = false;
                StateHasChanged();
            });
        }
        if (closeRequested)
        {
            await InvokeAsync(async () =>
            {
                await Task.Delay(10);

				isOpen = false;
				closeRequested = false;
                closing = true;
                StateHasChanged();
            });
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    public async Task OpenAsync()
    {
        if (disposed)
            throw new ObjectDisposedException(GetType().Name, $"Modal [{Id}] was disposed");

        if (isOpen)
            return;

        await ModalService.OpenAsync(item);
    }

    public async Task CloseAsync()
    {
        if (disposed)
            throw new ObjectDisposedException(GetType().Name, $"Modal [{Id}] was disposed");

        if (!isOpen)
            return;

        await ModalService.CloseAsync(item);
    }

    public async ValueTask DisposeAsync()
    {
        disposed = true;

        if (item.IsOpen)
            await ModalService.CloseAsync(item);

        await CompleteTransitionEndTask();

        ModalService.Remove(item);
    }
}
