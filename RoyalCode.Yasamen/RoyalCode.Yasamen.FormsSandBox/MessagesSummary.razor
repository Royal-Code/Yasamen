@using RoyalCode.Yasamen.Commons;
@using RoyalCode.OperationResult;
@using RoyalCode.Yasamen.Components;

@implements IDisposable

@if (messageListener is not null
   && messageListener.Messages.Any())
{
    var groups = messageListener.Messages
        .GroupBy(m => m.Type)
        .Select(g => new { Type = g.Key, Messages = g.ToList() })
        .OrderBy(g => g.Type);
    
    foreach(var group in groups)
    {
        var alertStyle = group.Type switch
        {
            ResultMessageType.Error => AlertStyles.Danger,
            ResultMessageType.Warning => AlertStyles.Warning,
            ResultMessageType.Info => AlertStyles.Info,
            ResultMessageType.Success => AlertStyles.Success,
            _ => AlertStyles.Danger
        };

        <Alert AlertStyle="alertStyle" AdditionalClasses="py-1">
            @foreach(var message in group.Messages)
            {
                <p>
                    @message.Text
                </p>
            }
        </Alert>
    }
}

@code {
    private readonly Action stateHasChangedDelegate;

    private IModelContext modelContext = null!;
    private IMessageListener? messageListener;

    public MessagesSummary()
    {
        stateHasChangedDelegate = StateHasChanged;
    }

    [Parameter]
    public object? Model { get; set; }

    [Parameter(CaptureUnmatchedValues = true)]
    public IReadOnlyDictionary<string, object>? AdditionalAttributes { get; set; }

    [CascadingParameter]
    IModelContext CascadeModelContext { get; set; } = default!;
    
    public override Task SetParametersAsync(ParameterView parameters)
    {
        parameters.SetParameterProperties(this);

        if (CascadeModelContext is null)
            throw new InvalidOperationException(
                $"{GetType()} requires a cascading parameter " +
                $"of type {nameof(IModelContext)}. For example, you can use {GetType()} inside " +
                $"an {nameof(ModelEditor<object>)}.");

        if (!ReferenceEquals(modelContext, CascadeModelContext))
        {
            Detach();
            modelContext = CascadeModelContext;
            messageListener = modelContext.EditorMessages.CreateFallbackListner(Model);
            messageListener.ListenChanges(stateHasChangedDelegate);
        }

        return base.SetParametersAsync(ParameterView.Empty);
    }
    
    private void Detach()
    {
        messageListener?.Dispose();
        messageListener = null;
    }

    void IDisposable.Dispose()
    {
        Detach();
        Dispose(disposing: true);
    }

    protected virtual void Dispose(bool disposing) { }
}
